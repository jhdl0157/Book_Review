# 3장 정리
## 계방/폐쇄 원칙(OCP)
계방 패쇄 원칙을 적용하는 사항은 이러하다.
- 여러 속성을 조합할수록 코드가 점점 복잡해진다.
- 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어려워진다.
- 코드를 반복한다.
개방/폐괘 원칙을 적용하면 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀수 있다.

기존코드
```java
public List<BankTransaction> findTransactionsGreaterThanEqual(final int amount){
    final List<BankTransaction> result=new ArrayList<>();
    for(final BankTransaction bankTransaction : bankTransactions){
        if(bankTransaction.getAmount >= amount){
            result.add(bankTransaction);
        }
    }
    return result;
}
```
여기서 추가적으로 특정월을 검색하는 기능을 구현한다면
```java
public List<BankTransaction> findTransactionsInMonth(final Month month){
    final List<BankTransaction> result=new ArrayList<>();
    for(final BankTransaction bankTransaction : bankTransactions){
        if(bankTransaction.getMonth == month){
            result.add(bankTransaction);
        }
    }
    return result;
}
```

이런방식에는 한계가 있다.

그래서 나온것이 함수형 인터페이스이다.

```java
@FunctionalInterface
public interface BankTransactionFilter{
    boolean test(BankTransaction bankTransaction);
}
```
```java
public List<BankTransaction> findTransactions(final BankTransactionFilter bankTransactionFilter) {
    final List<BankTransaction> result = new ArrayList<>();
    for (final BankTransaction bankTransaction : bankTransactions) {
        if (bankTransactionFilter.test(bankTransaction)) {
            result.add(bankTransaction);
        }
    }
    return result;
    }
```

하지만 요구 사항이 있을때마다 별도의 클래스를 만들어야한다. 이러한 문제를 해결하기 위해서 람다 표현식을 사용할수 있다.
람다 표현식을 이용해 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달할 수 있다.

```java
    final List<BankTransaction> transactions
            = bankStatementProcessor.findTransactions(
                    bankTransaction -> bankTransaction.getDate().getMonth() == Month.FEBRUARY
                    && bankTransaction.getMonth() >= 1_000);
```

인터페이스가 지나치게 세밀하면 코드 유지 보수에 방해가 된다. 자주 사용하는 기능을 쉽게 찾을수 있어야 유지보수성이 좋아진다.
